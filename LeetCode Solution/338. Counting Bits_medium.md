### solution：
```
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
	if(num == 0) return [0];
	if(num == 1) return [0, 1];
	let r = [0, 1];
	var loop = 1;

	while(2 * loop <= num) {
		loop *= 2;
		let i = 0;

		for(; i < loop && (i + loop <= num); i++) {
			r[i + loop] = r[i] + 1;

		}

	}
	return r;
};
console.log(countBits(17))
```


### 题目：

给定一个非负整数 num。 对于范围 0 ≤ i ≤ num 中的每个数字 i ，计算其二进制数中的1的数目并将它们作为数组返回。

示例：
比如给定 num = 5 ，应该返回 [0,1,1,2,1,2].

进阶：

给出时间复杂度为O(n * sizeof(integer)) 的解答非常容易。<br> 但是你可以在线性时间O(n)内用一次遍历做到吗？<br>
要求算法的空间复杂度为O(n)。<br>
你能进一步完善解法吗？ <br>在c ++或任何其他语言中不使用任何内置函数（如c++里的 __builtin_popcount）来执行此操作。

### 2018-07-12


规律是2的整倍数

|十进制表达|二进制表达|有几个1？| [r]+1 |
|--------|--------|--------|--------|
|0|0|0|
|1|01|1|
|2|10|1|[0]+1
|3|11|2|[1]+1
|4|100|1|[0]+1
|5|101|2|[1]+1
|6|110|2|[2]+1
|7|111|3|[3]+1
|8|1000|1|[0]+1
|9|1001|2|[1]+1
|10|1010|2|[2]+1
|11|1011|3|[3]+1
|12|1100|2|[4]+1
|13|1101|3|[5]+1
|14|1110|3|[6]+1
|15|1111|4|[7]+1
|16|10000|1|[0]+1
|17|10001|2|[1]+1


<br><br><br><br><br><br>

